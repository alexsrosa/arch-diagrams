@startuml
!include https://raw.githubusercontent.com/plantuml-stdlib/C4-PlantUML/master/C4_Container.puml

title Database Connection Pooling for Efficient Load Handling

Person(user1, "User 1", "Client making request")
Person(user2, "User 2", "Client making request")
Person(user3, "User 3", "Client making request")

System_Boundary(load_balancer, "Load Balancer") {
    Container(lb, "Load Balancer", "HAProxy/ALB", "Distributes requests")
}

System_Boundary(app_tier, "Application Tier") {
    Container(app1, "App Instance 1", "Java/Spring Boot", "Application server with connection pool")
    Container(app2, "App Instance 2", "Java/Spring Boot", "Application server with connection pool")
    Container(app3, "App Instance 3", "Java/Spring Boot", "Application server with connection pool")
}

System_Boundary(pool_layer, "Connection Pool Layer") {
    Container(pool1, "Connection Pool 1", "HikariCP/C3P0", "Pool: 10 connections")
    Container(pool2, "Connection Pool 2", "HikariCP/C3P0", "Pool: 10 connections")
    Container(pool3, "Connection Pool 3", "HikariCP/C3P0", "Pool: 10 connections")
}

System_Boundary(db_cluster, "Database Cluster") {
    ContainerDb(db_primary, "Primary DB", "PostgreSQL", "Write operations")
    ContainerDb(db_replica1, "Read Replica 1", "PostgreSQL", "Read operations")
    ContainerDb(db_replica2, "Read Replica 2", "PostgreSQL", "Read operations")
}

System_Boundary(monitoring, "Connection Pool Monitoring") {
    Container(metrics, "Pool Metrics", "Prometheus", "Connection pool statistics")
    Container(dashboard, "Dashboard", "Grafana", "Pool utilization visualization")
    Container(alerts, "Alerting", "AlertManager", "Pool exhaustion alerts")
}

' User interactions
Rel(user1, lb, "HTTP Request", "HTTPS")
Rel(user2, lb, "Concurrent Request", "HTTPS")
Rel(user3, lb, "High load request", "HTTPS")

' Load balancer routing
Rel(lb, app1, "Route to App 1", "HTTP")
Rel(lb, app2, "Route to App 2", "HTTP")
Rel(lb, app3, "Route to App 3", "HTTP")

' Application to connection pool relationships
Rel(app1, pool1, "Manages pool lifecycle", "Internal")
Rel(app2, pool2, "Manages pool lifecycle", "Internal")
Rel(app3, pool3, "Manages pool lifecycle", "Internal")

' Connection pool to database relationships
Rel(pool1, db_primary, "5 write connections", "SQL")
Rel(pool1, db_replica1, "3 read connections", "SQL")
Rel(pool1, db_replica2, "2 read connections", "SQL")

Rel(pool2, db_primary, "3 write connections", "SQL")
Rel(pool2, db_replica1, "4 read connections", "SQL")
Rel(pool2, db_replica2, "3 read connections", "SQL")

Rel(pool3, db_primary, "4 write connections", "SQL")
Rel(pool3, db_replica1, "3 read connections", "SQL")
Rel(pool3, db_replica2, "3 read connections", "SQL")

' Monitoring relationships
Rel(pool1, metrics, "Pool statistics", "HTTP")
Rel(pool2, metrics, "Pool statistics", "HTTP")
Rel(pool3, metrics, "Pool statistics", "HTTP")
Rel(metrics, dashboard, "Visualize metrics", "HTTP")
Rel(metrics, alerts, "Trigger alerts", "HTTP")

note right of pool1
  **Connection Pool Configuration:**
  • Maximum pool size: 10 connections
  • Minimum idle connections: 2
  • Connection timeout: 30 seconds
  • Idle timeout: 10 minutes
  • Max lifetime: 30 minutes
  • Leak detection threshold: 60 seconds
end note

note right of db_primary
  **Database Connection Limits:**
  • Primary DB: max_connections = 200
  • Each Replica: max_connections = 150
  • Reserved connections: 20 (admin)
  • Connection pooling reduces total connections
  • Prevents connection exhaustion
end note

note right of metrics
  **Pool Monitoring Metrics:**
  • Active connections count
  • Idle connections count
  • Connection wait time
  • Pool utilization percentage
  • Connection creation rate
  • Connection leak detection
  • Query execution time
end note

note left of app1
  **Connection Pool Benefits:**
  • Reduces connection overhead
  • Prevents connection exhaustion
  • Improves response times
  • Enables connection reuse
  • Provides connection lifecycle management
  • Supports connection validation
end note

note right of lb
  **Load Distribution Strategy:**
  • Round-robin across app instances
  • Health check integration
  • Session affinity (if needed)
  • Automatic failover
  • Connection draining during deployment
end note

note left of user1
  **Concurrent Request Handling:**
  • Multiple users served simultaneously
  • Connection pools prevent blocking
  • Efficient resource utilization
  • Graceful degradation under load
  • Queue management for peak traffic
end note

@enduml